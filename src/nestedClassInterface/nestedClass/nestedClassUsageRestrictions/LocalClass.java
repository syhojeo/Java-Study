/*
    로컬 클래스에서 사용제한
    로컬 클래스 내부에서는 바깥 클래스의 필드나 메소드를 제한없이 사용 할 수 있다.
    메소드가 실행되려면 어쨋든 매소드를 가지고 있는 바깥 객체가 생성되어 있어야 하기 때문

    하지만 로컬 클래스가 위치하는 메소드의 매개변수나 메소드의 로컬 변수를 로컬 객체에서 사용할 때 발생한다
    메소드의 매개변수나 로컬변수는 stack 메모리에 존재하며 메소드가 끝나면 자원을 반납하지만
    로컬 클래스이 객체가 생성되면 메소드가 종료되더라도 heap 메모리에 남아 메소드의 매개변수나 로컬변수를 사용해야 하기 때문이다

    때문에 자바는 이 문제를 해결하기 위해 처음 선언된 메소드의 매개변수와 로컬변수의 값을 로컬 클래스 내부에 복사해 두고 사용한다.
    로컬클래스의 메소드 내부에 저장 -> java8부터는 로컬클래스 필드에 저장
    (컴파일러가 자동으로 해줌)

    그러나 메소드에서 매개변수나 로컬변수가 수정되어 값이 변경되면 로컬클래스에 복사해둔 처음 선언된 값과 달라지는 문제가 또 발생하게 되는데
    이부분을 final 을 사용해서 값이 변경될 수 없도록 막아준다.

    때문에 로컬 클래스에서 사용할 수 있는 메소드의 매개변수와 로컬변수는 무조건 final 이 붙어있는 변수여야만 사용가능하다
    but 자바 8부터는 final을 적지 않아도 자동으로 매개변수와 로컬변수에 적용되어 사용이 가능해졌고, 명시하지 않은경우
    로컬클래스 메소드 내부에 저장하는것이 아니라 로컬클래스 필드에 저장하고,
    따로 final 명시하는경우 java8 이전 버전 처럼 로컬클래스 내부 메소드에 저장한다. 
    다만 두가지 모두 final 이 적용된다
    (컴파일러가 자동으로 해줌)

    중요!!
    하지만 로컬 클래스에서 사용하지 않는 메소드의 로컬변수나 매개변수는 final 특성을 갖지 않는다.

 */
package nestedClassInterface.nestedClass.nestedClassUsageRestrictions;

//자바 8 기준 컴파일러가 어떻게 매개변수와 로컬변수를 내부에 저장하는지
public class LocalClass {
    //final을 직접 명시해주는 것과 하지않는것 둘다 java8 이후부터는 final이 적용되지만
    //로컬 클래스 내부 어디에 저장되는지에 대한 차이가 있다
    void outMethod(final int arg1, int arg2) {
        final int var1 = 1;
        int var2 = 2;
        class RealLocalClass {
            /*
                final을 명시해주지 않은경우 로컬클래스의 필드로 컴파일러가 저장한다.
                final int arg2 = arg2
                fianl int var2 = var2
             */

            void method() {
                /*
                    final 을 명시해준경우 필드가 아니라 메소드 내부로 컴파일러가 저장한다.
                    fianl int arg1 = arg1;
                    final int var1 = var1;
                 */

                //arg1, arg2, var1, var2 똑같이 final 이 적용되어 사용된다
                // int result = arg1 + arg2 + var1 + var2
            }
        }
    }
}